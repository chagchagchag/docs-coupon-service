{"/about":{"title":"About","data":{"":"This is the about page! This page is shown on the navbar."}},"/coding-style/multi-module-usage":{"title":"Multi Module Usage","data":{"멀티모듈-구성-원칙#멀티모듈 구성 원칙":""}},"/coding-style/factory-mapper-usage":{"title":"Factory Mapper Usage","data":{"객체생성은-factory-mapper-컴포넌트를-사용#객체생성은 factory, mapper 컴포넌트를 사용":"이번 문서에서 다뤄볼 내용은 아래와 같습니다.\nEntity, Event 생성은 Factory 메서드에서 생성하도록 설계\nEntity 생성은 Factory 객체로 생성하게끔 코드의 구현과 설계를 했습니다.\nEntity 객체 생성을 코드 여기 저기에서 Lombok 의 builder 를 사용해서 Entity 객체를 생성하는 것이 2년 전에 신규 프로젝트를 수행할 때에는 이상할 정도로 신경이 쓰였습니다. 시간이 지나서 생각해보니 Entity 를 새로 생성하는 부분은 @Component 로 선언된 별도의 Factory 객체 내에 factory 메서드를 생성하는 것이 좋다는 생각에 도달했습니다.\n이렇게 하면 Entity 객체의 생성을 Factory 메서드에서 수행하면 코드레벨에서 하드코딩하는 것으로 인해 발생하는 의도에 어긋나는 객체생성 동작을 방지하게끔 하고 추후 유지보수 사항 발생시, 사용 중인 메서드를 수정하는 것으로 일괄적인 수정이 가능하도록 하는 것이 가능해지기 때문입니다.\n또한 객체 생성 구문을 테스트 해야 할때 Factory 메서드 하나만 수정하면 되기에 테스트 코드 관리에도 조금 더 요긴해집니다.\n객체 생성 메서드에 이름을 지정할 수 있고 메서드 오버로딩이 가능하기에 팩토리 메서드의 메서드 명과 인자 값들을 통해 어떤 역할을 하는지 유추할 수 있기에 사용성 측면에서도 장점이 큽니다.\n기본값 등에 대한 명세들을 제공하는 Enum 등과 결합해서 하나의 팩토리 메서드 들의 인자값의 생성 범위를 비즈니스 요건에 맞도록 지속적으로 규격화 할 수 있다는 점도 장점입니다.\nEvent 객체 생성 역시 factory 객체를 사용합니다.\nvalue object 는 mapper 를 통해 변환/생성하도록 설계\nAPI 계층의 Request/Response 또는 서로 다른 계층 간의 Value Object 변환 시에는 mapper 객체를 사용해서 변환/생성하도록 설계했습니다.\n이렇게 하면 객체 변환/생성 로직을 하드 코딩하는 것으로 인해 유지보수 사항이 발생했을 때 하드코딩 된 객체 생성 로직을 일일이 찾아서 고쳐야 하는 점을 방지할 수 있다는 것이 장점입니다.\n테스트 용도의 팩토리 메서드는 -Fixtures 라는 이름의 테스트 클래스에서 관리\n테스트 용도의 팩토리 메서드는 기존에 구현한 팩토리 메서드를 한번 더 감싸고 이름을 테스트에서 생성하려는 목적에 맞게끔 변경해주어서 테스트의 목적을 분간이 가능하도록 구성했습니다.","factory-mapper-객체는-모두-component-로-정의#Factory, Mapper 객체는 모두 @Component 로 정의":"Factory, Mapper 객체는 객체를 생성하는 로직을 규격화하기 위해 정의한 메서드입니다. 하지만, 이런 Factory, Mapper 객체 마저도 프로젝트 곳곳에서 직접 하드코딩으로 객체를 생성한다면, 요구사항 수정사항 발생 시 어떤 특정한 로직의 출발점을 찾아내는 것이 쉽지 않을 수 있습니다.보통 이런 경우 대부분의 애플리케이션 프레임워크에서는 객체를 생성하고 의존성을 주입할 수 있는 도구를 제공하는데 스프링 프레임워크 역시 이런 기능을 제공해줍니다.\r\n이런 이유로 -Factory, -Mapper 클래스들은 모두 @Component 로 선언해서 프레임워크에서 주입받아 사용하도록 정의했습니다.","eg-couponentityfactoryjava#e.g. CouponEntityFactory.java":"```java filename=\"CouponEntityFactory.java`  copy\r\n// ...\r\n@Component\r\npublic class CouponEntityFactory \n<br/>\r\n\r\n### e.g. CouponRequestMapper.java\r\n```java filename=\"CouponRequestMapper.java\" {0} copy\r\n@Component\r\npublic class CouponRequestMapper {\r\n    public CouponIssueQueueDto toCouponQueueIssueDto(CouponIssueRequest request){\r\n        return new CouponIssueQueueDto(request.userId(), request.couponId());\r\n    }\r\n}","entity-생성은-factory-메서드에서-생성하도록-설계#Entity 생성은 Factory 메서드에서 생성하도록 설계":"예를 들어 아래와 같은 필드들을 가지고 있는 CouponEntity 가 있습니다.","couponentityjava#CouponEntity.java":"// ...\r\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\r\n@Getter\r\n@Entity\r\n@Table(name = \"coupons\")\r\npublic class CouponEntity extends BaseDateTimeEntity {\r\n\r\n    @Id\r\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\r\n    private Long id;\r\n\r\n    @Column(nullable = false)\r\n    private String title;\r\n\r\n    @Column(nullable = false)\r\n    @Enumerated(value = EnumType.STRING)\r\n    private CouponAssignType couponAssignType;\r\n\r\n    private BigDecimal totalQuantity;\r\n\r\n    @Column(nullable = false)\r\n    private BigDecimal issuedQuantity;\r\n\r\n    @Column(nullable = false)\r\n    private BigDecimal discountAmount;\r\n\r\n    @Column(nullable = false)\r\n    private BigDecimal minAvailableAmount;\r\n\r\n    @Column(nullable = false, name = \"issue_start_datetime\")\r\n    private LocalDateTime issueStartDateTime;\r\n\r\n    @Column(nullable = false, name = \"issue_end_datetime\")\r\n    private LocalDateTime issueEndDateTime;\r\n\r\n    @Builder(builderClassName = \"DefaultBuilder\", builderMethodName = \"defaultBuilder\")\r\n    public CouponEntity(\r\n        Long id, String title,\r\n        CouponAssignType couponAssignType,\r\n        BigDecimal totalQuantity, BigDecimal issuedQuantity,\r\n        BigDecimal discountAmount, BigDecimal minAvailableAmount,\r\n        LocalDateTime issueStartDateTime, LocalDateTime issueEndDateTime\r\n    ){\r\n        this.id = id;\r\n        this.title = title;\r\n        this.couponAssignType = couponAssignType;\r\n        this.totalQuantity = totalQuantity;\r\n        this.issuedQuantity = issuedQuantity;\r\n        this.discountAmount = discountAmount;\r\n        this.minAvailableAmount = minAvailableAmount;\r\n        this.issueStartDateTime = issueStartDateTime;\r\n        this.issueEndDateTime = issueEndDateTime;\r\n    }\r\n\r\n    @Builder(builderClassName = \"FifoBuilderFromNow\", builderMethodName = \"fromNowFifoBuilder\")\r\n    public CouponEntity(\r\n        Long id,    String title,\r\n        BigDecimal totalQuantity, BigDecimal issuedQuantity,\r\n        BigDecimal discountAmount, BigDecimal minAvailableAmount,\r\n        LocalDateTime issueEndDateTime\r\n    ){\r\n        this.id = id;\r\n        this.title = title;\r\n        this.couponAssignType = CouponAssignType.FIFO;\r\n        this.totalQuantity = totalQuantity;\r\n        this.issuedQuantity = issuedQuantity;\r\n        this.discountAmount = discountAmount;\r\n        this.minAvailableAmount = minAvailableAmount;\r\n        this.issueStartDateTime = LocalDateTime.now();\r\n        this.issueEndDateTime = issueEndDateTime;\r\n    }\r\n\r\n    public Boolean hasIssueQuantityAvailable(){\r\n        if (wasNeverIssued()) return true;\r\n        return hasEnoughQuantity();\r\n    }\r\n\r\n    public Boolean wasNeverIssued(){\r\n        return totalQuantity == null;\r\n    }\r\n\r\n    public Boolean hasEnoughQuantity(){\r\n        if(totalQuantity == null) return true; // 쿠폰이 무한일 경우\r\n        return totalQuantity.compareTo(issuedQuantity) > 0;\r\n    }\r\n\r\n    public Boolean isIssueDateAvailable(){\r\n        LocalDateTime now = LocalDateTime.now();\r\n        return issueStartDateTime.isBefore(now) && issueEndDateTime.isAfter(now);\r\n    }\r\n\r\n    public void validateCouponIssuable(){\r\n        final LocalDateTime now = LocalDateTime.now();\r\n        if(!hasEnoughQuantity())\r\n            throw new CouponIssueException(EXCEEDED_COUPON_ISSUE_QUANTITY, EXCEEDED_COUPON_ISSUE_QUANTITY.message);\r\n\r\n        if(issueEndDateTime.isBefore(now))\r\n            throw new CouponIssueException(UNAVAILABLE_COUPON_ISSUE_DATE, UNAVAILABLE_COUPON_ISSUE_DATE.message);\r\n    }\r\n\r\n    public Boolean isCouponQuantityFull(){\r\n        LocalDateTime now = LocalDateTime.now();\r\n        return issueEndDateTime.isBefore(now) || !hasEnoughQuantity();\r\n    }\r\n\r\n    public void issue(){\r\n        if(!hasIssueQuantityAvailable())\r\n            throw new CouponIssueException(\r\n                EXCEEDED_COUPON_ISSUE_QUANTITY,\r\n                \"발급 가능 한도 초과 (total = %s, issued = %s)\".formatted(totalQuantity, issuedQuantity)\r\n            );\r\n\r\n        if(!isIssueDateAvailable()){\r\n            throw new CouponIssueException(\r\n                UNAVAILABLE_COUPON_ISSUE_DATE,\r\n                \"발급 가능 기간이 아닙니다. 요청일자 : %s, 발급 가능 기간 : %s ~ %s\".formatted(LocalDateTime.now(), issueStartDateTime, issueEndDateTime)\r\n            );\r\n        }\r\n\r\n        issuedQuantity = issuedQuantity.add(BigDecimal.ONE);\r\n    }\r\n}","couponentityfactoryjava#CouponEntityFactory.java":"CouponEntityFactory 클래스는 CouponEntity 객체를 생성하는 팩토리 객체 역할을 합니다.\r\n@Component 로 등록해서 스프링 컨테이너 내에서 객체의 생명주기가 관리되도록 했고, 스프링 프레임워크로부터 의존성 주입을 받을수 있도록 했습니다.\n// ... \r\n@Component\r\npublic class CouponEntityFactory {\r\n\r\n    /**\r\n     * title 외의 기본필드 설정이 갖춰진 Fifo 쿠폰을 생성 (할인액, 최소할인금액 등은 디폴트 값을 따름)\r\n     * @param title 쿠폰명\r\n     * @return CouponEntity\r\n     */\r\n    public CouponEntity newDefaultCoupon(\r\n        String title\r\n    ){\r\n        final LocalDateTime now = LocalDateTime.now();\r\n        final LocalDateTime end = now.plus(DefaultDuration.THOUSAND_DAY.getTemporalAmount());\r\n\r\n        return CouponEntity.defaultBuilder()\r\n                .title(title)\r\n                .couponAssignType(CouponAssignType.FIFO)\r\n                .totalQuantity(DefaultQuantity.TOTAL_QUANTITY.getQuantity())\r\n                .issuedQuantity(DefaultQuantity.ISSUED_QUANTITY.getQuantity())\r\n                .discountAmount(DefaultAmount.DISCOUNT_AMOUNT.getAmount())\r\n                .minAvailableAmount(DefaultAmount.MIN_AVAILABLE_AMOUNT.getAmount())\r\n                .issueStartDateTime(now)\r\n                .issueEndDateTime(end)\r\n                .build();\r\n    }\r\n\r\n    public CouponEntity newDefaultCoupon(\r\n        String title, Long couponId\r\n    ){\r\n        final LocalDateTime now = LocalDateTime.now();\r\n        final LocalDateTime end = now.plus(DefaultDuration.THOUSAND_DAY.getTemporalAmount());\r\n\r\n        return CouponEntity.defaultBuilder()\r\n                .id(couponId)\r\n                .title(title)\r\n                .couponAssignType(CouponAssignType.FIFO)\r\n                .totalQuantity(DefaultQuantity.TOTAL_QUANTITY.getQuantity())\r\n                .issuedQuantity(DefaultQuantity.ISSUED_QUANTITY.getQuantity())\r\n                .discountAmount(DefaultAmount.DISCOUNT_AMOUNT.getAmount())\r\n                .minAvailableAmount(DefaultAmount.MIN_AVAILABLE_AMOUNT.getAmount())\r\n                .issueStartDateTime(now)\r\n                .issueEndDateTime(end)\r\n                .build();\r\n    }\r\n\r\n    /**\r\n     * title, totalQuantity 외의 기본필드 설정이 갖춰진 Fifo 쿠폰을 생성 (할인액, 최소할인금액 등은 디폴트 값을 따름)\r\n     * @param title 쿠폰 명\r\n     * @param totalQuantity 쿠폰 전체 수량\r\n     * @return CouponEntity\r\n     */\r\n    public CouponEntity newDefaultCoupon(\r\n        String title,\r\n        BigDecimal totalQuantity\r\n    ){\r\n        final LocalDateTime now = LocalDateTime.now();\r\n        final LocalDateTime end = now.plus(DefaultDuration.THOUSAND_DAY.getTemporalAmount());\r\n\r\n        return CouponEntity.defaultBuilder()\r\n                .title(title)\r\n                .couponAssignType(CouponAssignType.FIFO)\r\n                .totalQuantity(totalQuantity)\r\n                .issuedQuantity(BigDecimal.ZERO)\r\n                .discountAmount(DefaultAmount.DISCOUNT_AMOUNT.getAmount())\r\n                .minAvailableAmount(DefaultAmount.MIN_AVAILABLE_AMOUNT.getAmount())\r\n                .issueStartDateTime(now)\r\n                .issueEndDateTime(end)\r\n                .build();\r\n    }\r\n\r\n    public CouponEntity newDefaultCoupon(\r\n        String title,\r\n        BigDecimal totalQuantity, BigDecimal issuedQuantity\r\n    ){\r\n        final LocalDateTime now = LocalDateTime.now();\r\n        final LocalDateTime end = now.plus(DefaultDuration.THOUSAND_DAY.getTemporalAmount());\r\n\r\n        return CouponEntity.defaultBuilder()\r\n                .title(title)\r\n                .couponAssignType(CouponAssignType.FIFO)\r\n                .totalQuantity(totalQuantity)\r\n                .issuedQuantity(issuedQuantity)\r\n                .discountAmount(DefaultAmount.DISCOUNT_AMOUNT.getAmount())\r\n                .minAvailableAmount(DefaultAmount.MIN_AVAILABLE_AMOUNT.getAmount())\r\n                .issueStartDateTime(now)\r\n                .issueEndDateTime(end)\r\n                .build();\r\n    }\r\n\r\n    public CouponEntity newInfiniteCoupon(\r\n        String title\r\n    ){\r\n        final LocalDateTime now = LocalDateTime.now();\r\n        final LocalDateTime end = now.plus(DefaultDuration.THOUSAND_DAY.getTemporalAmount());\r\n\r\n        return CouponEntity.defaultBuilder()\r\n                .title(title)\r\n                .couponAssignType(CouponAssignType.FIFO)\r\n                .totalQuantity(null)\r\n                .issuedQuantity(DefaultQuantity.ISSUED_QUANTITY.getQuantity())\r\n                .discountAmount(DefaultAmount.DISCOUNT_AMOUNT.getAmount())\r\n                .minAvailableAmount(DefaultAmount.MIN_AVAILABLE_AMOUNT.getAmount())\r\n                .issueStartDateTime(now)\r\n                .issueEndDateTime(end)\r\n                .build();\r\n    }\r\n\r\n    public CouponEntity newDefaultCouponWithExpiration(\r\n        String title,\r\n        LocalDateTime issueStartDateTime,\r\n        LocalDateTime issueEndDateTime\r\n    ){\r\n        return CouponEntity.defaultBuilder()\r\n                .title(title)\r\n                .couponAssignType(CouponAssignType.FIFO)\r\n                .totalQuantity(DefaultQuantity.TOTAL_QUANTITY.getQuantity())\r\n                .issuedQuantity(DefaultQuantity.ISSUED_QUANTITY.getQuantity())\r\n                .discountAmount(DefaultAmount.DISCOUNT_AMOUNT.getAmount())\r\n                .minAvailableAmount(DefaultAmount.MIN_AVAILABLE_AMOUNT.getAmount())\r\n                .issueStartDateTime(issueStartDateTime)\r\n                .issueEndDateTime(issueEndDateTime)\r\n                .build();\r\n    }\r\n\r\n    public CouponEntity newDefaultCouponWithExpiration(\r\n            String title,\r\n            BigDecimal issuedQuantity\r\n    ){\r\n        final LocalDateTime now = LocalDateTime.now();\r\n        final LocalDateTime end = now.plus(DefaultDuration.THOUSAND_DAY.getTemporalAmount());\r\n\r\n        return CouponEntity.defaultBuilder()\r\n                .title(title)\r\n                .couponAssignType(CouponAssignType.FIFO)\r\n                .totalQuantity(DefaultQuantity.TOTAL_QUANTITY.getQuantity())\r\n                .issuedQuantity(issuedQuantity)\r\n                .discountAmount(DefaultAmount.DISCOUNT_AMOUNT.getAmount())\r\n                .minAvailableAmount(DefaultAmount.MIN_AVAILABLE_AMOUNT.getAmount())\r\n                .issueStartDateTime(now)\r\n                .issueEndDateTime(end)\r\n                .build();\r\n    }\r\n\r\n    public CouponEntity newDefaultCouponWithExpiration(\r\n            String title,\r\n            BigDecimal issuedQuantity,\r\n            LocalDateTime issueStartDateTime, LocalDateTime issueEndDateTime\r\n    ){\r\n        return CouponEntity.defaultBuilder()\r\n                .title(title)\r\n                .couponAssignType(CouponAssignType.FIFO)\r\n                .totalQuantity(DefaultQuantity.TOTAL_QUANTITY.getQuantity())\r\n                .issuedQuantity(issuedQuantity)\r\n                .discountAmount(DefaultAmount.DISCOUNT_AMOUNT.getAmount())\r\n                .minAvailableAmount(DefaultAmount.MIN_AVAILABLE_AMOUNT.getAmount())\r\n                .issueStartDateTime(issueStartDateTime)\r\n                .issueEndDateTime(issueEndDateTime)\r\n                .build();\r\n    }\r\n\r\n    public CouponEntity newDefaultCouponWithExpiration(\r\n        String title,\r\n        BigDecimal totalQuantity, BigDecimal issuedQuantity,\r\n        LocalDateTime issueStartDateTime, LocalDateTime issueEndDateTime\r\n    ){\r\n        return CouponEntity.defaultBuilder()\r\n                .title(title)\r\n                .couponAssignType(CouponAssignType.FIFO)\r\n                .totalQuantity(totalQuantity)\r\n                .issuedQuantity(issuedQuantity)\r\n                .discountAmount(DefaultAmount.DISCOUNT_AMOUNT.getAmount())\r\n                .minAvailableAmount(DefaultAmount.MIN_AVAILABLE_AMOUNT.getAmount())\r\n                .issueStartDateTime(issueStartDateTime)\r\n                .issueEndDateTime(issueEndDateTime)\r\n                .build();\r\n    }\r\n\r\n}\n주요 메서드는 newDefaultCoupon(...), newInfiniteCoupon(title), newDefaultCouponWithExpiration(...) 이 있고, 인자값을 통해 의도를 파악할 수 있도록 구성했고, 디폴트 값을 설정하는 부분의 경우 Enum 을 통해서 디폴트 값이 설정될 수 있도록 구성했습니다.newDefaultCoupon(...) : 기본 디폴트 옵션 필드들이 설정된 객체를 생성하는 역할을 수행\nnewDefaultCoupon(String title)\n쿠폰명 하나만 지정하고, 나머지 필드들은 기본값으로 채웁니다.\nnewDefaultCoupon(String title, Long couponId)\n쿠폰명, 쿠폰 ID 만 지정하고, 나머지 필드들은 기본값으로 채웁니다.\nnewDefaultCoupon(String title, BigDecimal totalQuantity)\n쿠폰명, 발행가능 총량 만 지정하고 나머지 필드들은 기본값으로 채웁니다.\nnewDefaultCoupon(String title, BigDecimal totalQuantity, BigDecimal issuedQuantity)\n쿠폰명, 발행가능 총량, 발행 쿠폰 수(issuedQuantity)를 지정하고 나머지 필드들은 기본값으로 채웁니다.\nnewInfiniteCoupon(...) : 발행 가능 쿠폰 수가 무한 일때에 대한 팩토리 메서드입니다.\nnewInfiniteCoupon(String title)\n발행 가능 쿠폰수가 무한일 때에 대한 객체 생성을 하는 팩토리 메서드 입니다.\nnewDefaultCouponWithExpiration(...) : 만료기한을 직접 지정하되 나머지 필드들은 기본값으로 지정하는 메서드 들 입니다.\nnewDefaultCouponWithExpiration(String title, LocalDateTime issueStartDateTime, issueEndDateTime)\n쿠폰명, 발행시작일자, 발행종료일자는 직접 지정하고 나머지 필드들은 디폴트 값으로 설정하는 팩토리 메서드 입니다.\nnewDefaultCouponWithExpiration(String title, BigDecimal issuedQuantity)\n쿠폰명, 발행 쿠폰 수량은 직접 지정하고 나머지 필드들은 디폴트 값으로 설정하는 팩토리 메서드 입니다.\nnewDefaultCouponWithExpiration(String title, BigDeciaml issuedQuantity, LocalDateTime issueStartDateTime, issueEndDateTime)\n쿠폰명, 발행 쿠폰 수량, 발행시작일자, 발행종료일자를 직접 지정하고 나머지 필드들은 모두 디폴트 값으로 설정하는 팩토리 메서드 입니다.\nnewDefaultCouponWithExpiration(String title, BigDecimal totalQuantity, BigDeciaml issuedQuantity, LocalDateTime issueStartDateTime, LocalDateTime issueEndDateTime)\n쿠폰명, 발행 쿠폰 최대치, 발행 쿠폰 수량, 발행시작일자, 발행종료일자를 직접 지정하고 나머지 필드들은 모두 디폴트 값으로 설정하는 팩토리 메서드 입니다.","value-object-는-mapper-를-통해-변환생성하도록-설계#value object 는 mapper 를 통해 변환/생성하도록 설계":"엄청나게 복잡한 내용은 아니지만, 요약해보면 이렇습니다.\r\nRequest 객체를 QueueDto 로 변환 후에 cache 계층 내의 queue 서비스에 전달해주어야 하는데 여기에 대해서 객체의 변환 작업 및 객체 생성을 @Service 내에서 바로 하드코딩으로 수행하는 것이 아니라 CouponRequestMapper 라는 이름의 컴포넌트 내에서 수행하도록 지정하는 것입니다.\r\n이렇게 하면, 다른 계층의 변경사항이 @Service 에 까지 전이되지 않고 Mapper 클래스 내부의 변환 메서드만 변경해주면 된다는 유지 보수 상의 장점이 있습니다.\n@Component\r\npublic class CouponRequestMapper {\r\n    public CouponIssueQueueDto toCouponQueueIssueDto(CouponIssueRequest request){\r\n        return new CouponIssueQueueDto(request.userId(), request.couponId());\r\n    }\r\n}","테스트-용도의-팩토리-메서드는--fixtures-라는-이름의-테스트-클래스에서-관리#테스트 용도의 팩토리 메서드는 -Fixtures 라는 이름의 테스트 클래스에서 관리":"테스트 용도의 팩토리 메서드는 기존에 구현한 팩토리 메서드를 한번 더 감싸고 이름을 테스트에서 생성하려는 목적에 맞게끔 변경해주어서 테스트의 목적을 분간이 가능하도록 구성했습니다.","eg-couponentityfixturesjava#e.g. CouponEntityFixtures.java":"package io.chagchagchag.project.coupon.dataaccess.fixtures;\r\n\r\n// ..\r\n\r\npublic class CouponEntityFixtures {\r\n    private static final CouponEntityFactory couponEntityFactory = new CouponEntityFactory();\r\n    public static CouponEntity ofNoError(){\r\n        return couponEntityFactory.newDefaultCoupon(\"\");\r\n    }\r\n\r\n    public static CouponEntity ofNoError(Long couponId){\r\n        return couponEntityFactory.newDefaultCoupon(\"\", couponId);\r\n    }\r\n\r\n    public static CouponEntity ofInvalidQuantity1(){\r\n        return couponEntityFactory.newDefaultCoupon(\r\n            \"\",\r\n                BigDecimal.ONE, BigDecimal.TWO\r\n        );\r\n    }\r\n\r\n    public static CouponEntity ofInvalidIssueDate1(){\r\n        return couponEntityFactory.newDefaultCouponWithExpiration(\r\n            \"\",\r\n                BigDecimal.TWO,BigDecimal.ONE,\r\n                LocalDateTime.now().minusDays(3), LocalDateTime.now().minusDays(2)\r\n        );\r\n    }\r\n\r\n}"}},"/coding-style/domain-event-driven":{"title":"Domain Event Driven","data":{"도메인-이벤트-기반-데이터-처리#도메인 이벤트 기반 데이터 처리":"이번 예제 프로젝트에서는 예제 정도의 레벨에서 싱글 인스턴스에서의 도메인 이벤트 기반 데이터 처리를 예제로 만들었습니다.트래픽이 높아질 경우에 대해서는 보통 SAGA, Outbox 와 함께 분산환경에서의 EDA (Event Driven Architecture) 구조로 전환을 하겠지만, 이번 documentation 페이제서는 이런 내용들은 제외하고 가능한 한도 내에서 가장 단순한 구조로 예제를 마련했습니다.도메인 이벤트 기반 데이터 처리는 데이터 영역(JPA, Querydsl, Mybatis, Jdbctemplate) 에서 데이터의 생성/수정/삭제 등의 연산이 발생했을 때 이것에 대해 도메인 이벤트를 발급(Publish) 하는 것으로 dataaccess 에서의 역할을 수행합니다.\r\n그리고 도메인 이벤트를 수신하는 리스너 측에서 이 도메인 이벤트내의 정보 (id, 필드 값 등)을 이용해서 후처리(Cache Put, 메일 전송 등)작업을 수행하게 됩니다.\r\n이렇게 dataaccess 계층에서 변경이 발생하면 이벤트를 발급(publish)하고 domain 계층의 리스너에서 이벤트를 수신(Listen)했을 경우 이에 맞는 비즈니스 처리를 수행하는 방식으로 하는 것을 도메인 이벤트 기반 데이터처리라고 이야기합니다. 이렇게 하는 것의 장점은 dataaccess 측에서는 데이터 처리에만 집중하고 비즈니스 로직의 간섭이 줄고 프로젝트 전반적으로 결합도가 떨어지기에 프로젝트의 콜스택을 추적해서 유지보스를 해야 하는 피로도를 다소 낮출수 있다는 장점이 있습니다Coupon 발급 시나리오를 요약해보면 다음과 같습니다.\ndataaccess 계층에서 couponId 에 대해 데이터를 저장\n데이터를 저장하는 동작은 domain 계층에서는 DomainEvent 로 간주되는데, 따라서 domain 계층에서는 CouponIssueCreatedEvent 를 생성해서 스프링 컨테이너 내에 이벤트를 전송합니다.\n스프링 컨테이너 내의 @TransactionalEventHandler 와 함께 이벤트 타입을 정의한 CouponIssueCreatedEvent 에 대한 리스너에서 도메인 이벤트에 맞는 후처리 작업을 수행합니다.","couponissuerscheduler#CouponIssuerScheduler":"데이터 저장 작업 완료 → CouponIssueCreatedEvent 발급을 하는 과정입니다.\r\n데이터를 저장하는 로직은 아래와 같습니다. 데이터 저장이 완료되면 CouponIssueCreatedEvent를 발급합니다. 데이터 발급 작업에만 집중하고 데이터 커밋이 이뤄진 후의 이후의 작업은 Listener 측에 위임합니다.\npackage io.chagchagchag.project.coupon.issuer.application;\r\n\r\n// ...\r\n\r\n@Slf4j\r\n@RequiredArgsConstructor\r\n@EnableScheduling\r\n@Component\r\npublic class CouponIssuerScheduler {\r\n    private final CouponIssueRedisRepository couponIssueRedisRepository;\r\n    private final CouponIssueDataAccessService couponIssueDataAccessService;\r\n    private final CouponDomainService couponDomainService;\r\n\r\n    @Scheduled(fixedDelay = 1000)\r\n    @Transactional\r\n    public void issue() throws JsonProcessingException {\r\n        // ...\r\n        while(couponIssueRedisRepository.existsWaitingForBeingIssued()){\r\n            // 작업 큐 인출 (poll())\r\n            CouponIssueQueueDto queueDto = couponIssueRedisRepository.pollOne();\r\n\r\n            // 쿠폰 발급 (issue)\r\n            couponIssueDataAccessService.issue(queueDto.couponId(), queueDto.userId());\r\n\r\n            // DomainEvent Publish\r\n            log.info(\"[Publish] start >> \" + queueDto);\r\n            couponDomainService.publishEvent(queueDto.couponId());\r\n            log.info(\"[Publish] end >> \" + queueDto);\r\n            couponIssueRedisRepository.removeOldestOne();\r\n        }\r\n    }\r\n}","coupondomainservicepulisheventcouponid#CouponDomainService::pulishEvent(couponId)":"쿠폰 도메인 이벤트를 발급(pulish) 하는 로직입니다.\r\n스프링 컨테이너 내에 CouponIssueCreatedEvent 를 발급(publish)합니다.\npackage io.chagchagchag.project.coupon.issuer.domain;\r\n\r\n// ...\r\n\r\n@Slf4j\r\n@RequiredArgsConstructor\r\n@Service\r\npublic class CouponDomainService {\r\n    private final ApplicationEventPublisher applicationEventPublisher;\r\n    private final CouponIssueCreatedEventFactory couponIssueCreatedEventFactory;\r\n\r\n    private final CouponCacheService couponCacheService;\r\n\r\n    public void publishEvent(Long couponId){\r\n        final CouponIssueCreatedEvent couponIssueCreatedEvent = couponIssueCreatedEventFactory.defaultEvent(couponId);\r\n        applicationEventPublisher.publishEvent(couponIssueCreatedEvent);\r\n    }\r\n\r\n    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)\r\n    public void onCouponIssueCreatedEvent(CouponIssueCreatedEvent event){\r\n        // ...\r\n    }\r\n}","couponissuecreatedevent#CouponIssueCreatedEvent":"쿠폰 생성 이벤트 발생시 생성할 객체인 CouponIssueCreatedEvent 는 아래와 같습니다.\npublic record CouponIssueCreatedEvent(\r\n    Long couponId\r\n) {\r\n}","transacationaleventlistener#@TransacationalEventListener":"도메인 이벤트 리스너입니다.\r\nCouponIssueCreatedEvent 를 수신한 후 데이터 저장 후의 후처리 작업을 수행하는 도메인 이벤트 리스너의 모습은 아래와 같습니다.\npackage io.chagchagchag.project.coupon.issuer.domain;\r\n// ...\r\n@Slf4j\r\n@RequiredArgsConstructor\r\n@Service\r\npublic class CouponDomainService {\r\n    private final ApplicationEventPublisher applicationEventPublisher;\r\n    private final CouponIssueCreatedEventFactory couponIssueCreatedEventFactory;\r\n    private final CouponCacheService couponCacheService;\r\n\r\n    public void publishEvent(Long couponId){\r\n        // ...\r\n    }\r\n\r\n    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)\r\n    public void onCouponIssueCreatedEvent(CouponIssueCreatedEvent event){\r\n        log.info(\"issue complete. Domain Event handler start >>> \");\r\n        couponCacheService.putRedisCouponCache(event.couponId());\r\n        couponCacheService.putLocalCouponCache(event.couponId());\r\n        log.info(\"issue complete. Domain Event handler end >>> \");\r\n    }\r\n}\n데이터를 저장한 이후에는 API 에서 Redis 에 어떤 Coupon 들이 있는지 조회할 수 있도록 couponId 를 저장합니다."}},"/performance-test/grafana-dashboard-setting":{"title":"Grafana Dashboard Setting","data":{"grafana-dashboard-세팅#Grafana Dashboard 세팅":"Tomcat 커넥션이 얼마나 증가하는지를 보기 위한 지표 차트를 세팅합니다.Utilisation 내의 점 세개 버튼 클릭 → More ... → Duplicate 클릭\r\n이동한 페이지에서는 오른쪽의 Builder 버튼 클릭 후 Metric 중에서 tomcat_connections_current_connections 를 선택합니다. 그리고 Run queries 를 클릭합니다.\r\nOptions 버튼 클릭 후 Legend 항목에는 톰캣 커넥션 (current) 를 입력해줍니다. 이어서 오른쪽에서 Panel Options 의 Title 도 아래와 같이 알아볼 수 있는 제목을 지어줍니다.\r\n모두 완료되었으면 우측 상단의 Apply 버튼을 클릭합니다.\r\n대시보드 페이지에서는 변경된 사항을 저장하기 위해 디스켓 모양의 버튼을 클릭해서 현재 대시보드의 상태를 저장합니다."}},"/coding-style/simplify-object-dependency":{"title":"Simplify Object Dependency","data":{"객체-간-의존성-단순화-순환참조-방지#객체 간 의존성 단순화 (순환참조 방지)":"엄청나게 어려운 이야기는 아니지만, 실무에서 유지보수를 하는 중에 기능 추가 시에 순환참조가 발생하는 경우가 가끔씩 있었고 이런 경우를 우회하기 위해 별도의 객체를 생성해서 우회했던 경험이 있습니다.이런 경우가 어떤 경우였을까를 생각해보면 보통 Service A 에서 어떤 단위기능들을 조합해서 호출하고 있는데 요구사항에 따라 Service B 를 호출하게 되었습니다. 시간이 흘러서 Service B 에서도 Service A 를 호출해야만 하는 경우가 발생했습니다.이런 경우 순환 참조가 발생합니다.\r\n이런 문제를 풀어낼 수 있는 가장 쉬운 방법은 Service 내에서 다른 Service 를 의존성 주입받지 않도록 하고, 하나의 Service 가 하나의 역할만을 담당하도록 하는 것입니다.조금 두루뭉술하게 설명했는데, 결론은 대리인 역할을 하는 하나의 프록시 역할의 객체를 두어서 어떤 기능을 필요로 할 때 이 프록시 객체를 통해서 호출하도록 하는 것입니다.그리고 같은 계층 내의 각각의 대리인 객체들 각각은 서로를 의존하거나 의존성주입 받지 않고 독립적으로 존재하도록 구성합니다.계층이나 모듈의 기능이나 역할을 명확히 해두어서 그 계층에서의 대리인 역할의 객체는 다른 객체에 의존하지 않도록 계층이나 모듈이 의미와 기능을 명확히 하도록 구성하면 이런 작업들이 쉬워지게 됩니다.이번 프로젝트에서는 애플리케이션의 하위 모듈들 내에서 필요한 대표적인 기능들을 application, dataaccess, domain 계층으로 분류했고 계층별 대리인 객체의 기능을 정해두면서 설계를 했고 이런 기능들은 멀티 모듈로 분리해서 개발작업을 하면서 더 세분화 되었던 것 같습니다.","기본적인-컨셉-및-원칙들#기본적인 컨셉 및 원칙들":"주요 원칙은 아래와 같습니다.\n단위 기능 클래스 안에서 다른 단위기능 클래스를 의존성 주입받지 않는다. 단위기능 클래스는 단위 기능을 하는 데에만 집중한다.\n단위 기능을 접근할 때는 @Service 로 정의한 컴포넌트를 통해 접근한다. @Service 에서는 단위기능을 불러들여서 의존성을 주입받아서 비즈니스 로직을 정의한다.\n하나의 계층에 존재하는 Service A 와 Service B 는 서로를 참조하지 않으며 의존성 주입 역시 받지 않는 서로 독립적인 객체로 정의하는 것을 원칙으로 한다.\n이렇게 중간에서 각각이 독립적인 역할을 하도록 Service 객체를 구성하며 대리인 역할을 하게끔 한다. 이렇게 대리인 역할의 객체에게만 @Service 어노테이션을 붙이기로 하며, -Service 접미사를 붙인다.\n그 외의 단위기능의 경우 Repository 로 정의하거나 @Component 로 정의해서 단위 기능임을 확실하게 표현한다.\ne.g. application 계층에서 dataaccess 계층의 CouponJpaRepository 를 접근하려는 경우\ncoupon-api 모듈 내의 application 계층에서는 단순하게 dataaccess 계층에서 대리인 역할을 하는 객체만 알고 있으면 되고 어떤 함수를 호출하면 되는지만 알면 됩니다.\n따라서 CouponApiApplicationService 에서는 Data에 접근이 필요할 경우 단순하게 CouponDataAccessService 라는 대리인 객체를 의존성 주입 받은 후 CouponDataAccessService 내에 정의해둔 비즈니스 로직을 통해서 접근하도록 하면 됩니다.","eg-issue-로직을-통해-mysql에-쿠폰을-발급하는-기능#e.g. issue() 로직을 통해 MySQL에 쿠폰을 발급하는 기능":"","eg-api-의-request-를-redis-에-enqueue-하는-기능#e.g. API 의 Request 를 Redis 에 enqueue 하는 기능":""}},"/performance-test/locust-setting":{"title":"Locust Setting","data":{"locust-세팅#Locust 세팅":"Locust 에서는 아래와 같이 세팅을 해줍니다. 1100 명의 User 인입을 테스트하는 것이고 1초에 100 명의 유저를 생성해냅니다. Host 는 http://host.docke.internal:8080 로 지정했습니다.\r\n모두 선택했다면 Start Swarming 을 눌러서 실행합니다."}},"/performance-test/testing-note":{"title":"Testing Note","data":{"테스팅-기록#테스팅 기록":"","coupon-데이터-생성#Coupon 데이터 생성":"쿠폰의 발급 가능한 총 개수를 1000 으로 설정했습니다. 1100 명의 사용자가 요청을 하더라도 1000명 까지만 발급이 가능합니다.\nINSERT INTO coupon.coupons(\r\n    title, coupon_assign_type, total_quantity, issued_quantity, discount_amount,\r\n    min_available_amount, issue_start_datetime, issue_end_datetime, created_datetime, updated_datetime\r\n)\r\nVALUES (\r\n           '50% 세일. 과연 누가 주인공이 될 것인가?', 'FIFO', 1000, 0, 50,\r\n           1000, '2024-01-01 00:00:01', '2024-11-11 23:59:59', '2023-12-31 23:00:00', '2023-12-31 23:00:00'\r\n       );\r\n\r\nCOMMIT;","locust#Locust":"먼저 Locust 에서 아래의 세팅을 통해서 아래의 테스트 조건을 걸어주고 테스트를 시작합니다.","데이터-저장-확인#데이터 저장 확인":"coupon_issues 테이블에는 아래와 같이 1000개의 coupon 이 정상적으로 저장되어 있음을 확인 가능합니다.\r\ncoupons 테이블에는 아래와 같이 정상적으로 issued_quantity 가 1000 으로 정상적으로 세팅된 것을 확인 가능합니다.","레디스-확인#레디스 확인":"","데이터-요청-대기열-확인#데이터 요청 대기열 확인":"요청 대기열은 아래와 같이 테스트 초기에는 936 개의 요청을 저장하고 있습니다.\r\n잠시 동안의 순간에 Refresh 버튼을 눌러서 새로 변경된 내용을 조회해보면 아래와 같이 473 개의 요청으로 줄어들어 있습니다.\r\n정상적으로 작업 대기열이 비워지고 있습니다.","데이터-요청-기록-set-확인#데이터 요청 기록 SET 확인":"SortedSet 을 사용할수도 있겠지만, Set과 List 를 조합한 FIFO 구조로 작업 대기열을 구성했는데, List 를 통해 FIFO 를 구현했고, 요청 각각은 Set 을 통해 요청 고유값을 식별합니다. 따라서 Set 의 Size 가 1000 개라면 정상적으로 요청을 모두 받아두었다는 것을 확인 가능합니다.","grafana-확인#Grafana 확인":"coupon-api 의 상태를 그라파나를 통해 확인해봅니다. locust 를 통해 coupon-api 로 유입되어서 톰캣 커넥션 수가 증가하고, 레디스에 접근하는 IO 작업 역시 증가함을 확인 가능합니다.\r\ncoupon-issuer 의 상태입니다."}},"/project-overview/locust-setting":{"title":"Locust Setting","data":{"locust-세팅하기#locust 세팅하기":"locust 는 성능부하를 테스트하기 위한 테스트입니다. docker-compose 등을 통해 스케일링이 가능하고, 기본으로 제공하는 dashboard 도 강력하기에 성능부하를 실험하고, 측정하기에 용이한 도구입니다.","참고#참고":"locust.io\ndocs.locust.io/en/stable","api-정의#API 정의":"테스트할 API 를 정의합니다.\n@RequiredArgsConstructor\r\n@RestController\r\npublic class CouponApiController {\r\n\r\n    private final CouponApplicationService couponApplicationService;\r\n\r\n    @PostMapping(\"/coupon/issue\")\r\n    public CouponIssueResponse issue(@RequestBody CouponIssueRequest request){\r\n        couponApplicationService.issueAsync(request);\r\n        return new CouponIssueResponse(SUCCESS, SUCCESS.getMessageKr());\r\n    }\r\n\r\n}\n위의 코드에서 CouponApplicationService 클래스 내의 issueAsync(request) 메서드는 아무 동작도 하지 않는 비어있는 메서드입니다.","docker-compose#docker-compose":"docker-compose 파일을 아래와 같이 작성해줍니다.\nversion: '3.7'\r\nservices:\r\n  master:\r\n    image: locustio/locust\r\n    ports:\r\n      - \"8089:8089\"\r\n    volumes:\r\n      - ./:/mnt/locust\r\n    command: -f /mnt/locust/locustfile-coupon-request.py --master -H http://host.docker.internal:8080\r\n\r\n  worker:\r\n    image: locustio/locust\r\n    volumes:\r\n      - ./:/mnt/locust\r\n    command: -f /mnt/locust/locustfile-coupon-request.py --worker --master-host master","python-파일-정의#python 파일 정의":"import random\r\nfrom locust import task, FastHttpUser, stats\r\n\r\nstats.PERCENTILES_TO_CHART = [0.95, 0.99]\r\n\r\n\r\nclass CouponRequest(FastHttpUser):\r\n    connection_timeout = 10.0\r\n    network_timeout = 10.0\r\n\r\n    @task\r\n    def issue(self):\r\n        payload = {\r\n            \"userId\": random.randint(1, 10000000),\r\n            \"couponId\": 1\r\n        }\r\n        with self.rest(\"POST\", \"/coupon/issue\", json=payload):\r\n            pass","실행#실행":"아래의 명령어를 통해 실행합니다.\ndocker-compose up -d --scale worker=3","docker-desktop-확인#Docker Desktop 확인":"아래와 같이 worker 3기, master 1의 구성으로 docker 애플리케이션이 구동된 모습을 확인 가능합니다.","locust-애플리케이션-접속#locust 애플리케이션 접속":"","load-설정#load 설정":"Number of users\n몇명의 사용자까지 만들어낼 것인지\n위의 사진에서는 10만명까지의 유입을 만들어내겠다는 의미\nSpawn rate\n1초에 몇명의 사용자를 생성해낼 것인지\n위의 사진에서는 1초에 1000명씩 유저를 생성되어서 유입되게끔 했습니다.\n1초: 1000명, 2초: 2000명, 3초: 3000명, ... 100초 : 100000명\nHost\n요청을 보낼 주소","load-테스트#load 테스트":"로드를 spawning 하고 있는 모습\r\n차트 탭\r\nFailures 탭\r\n요청이 실패한 것의 기록이다.\r\n이번에는 Workers 탭으로 이동한다. 자세히 보면 CPU 사용률이 100% 이상으로 올라가고 있다.\r\nworker 들의 로드를 줄여주기 위해 이번에는 worker 수를 7개로 늘려봅니다.\n$ docker-compose scale worker=7\n각 worker 의 cpu 사용량은 줄어들었습니다."}},"/project-overview/prometheus-grafana-setting":{"title":"Prometheus Grafana Setting","data":{"prometheus-grafana-세팅#prometheus, grafana 세팅":"Prometheus 를 통해 애플리케이션이 모니터링 가능하도록 하고, Grafana 로 모니터링하는 과정을 설명합니다.\r\n이론적인 내용이나 개념도 설명할까 했는데, 피곤해서 거기까지는 설명을 못하고 어떻게 하는지만 설명을 남겨두기로 했습니다.","coupon-api#coupon-api":"","buildgradlekts#build.gradle.kts":"spring-boot-starter-actuator, micrometer-registry-prometheus 를 의존성으로 추가해줍니다.\n// ...\r\n\r\ndependencies {\r\n    // ...\r\n\r\n    // prometheus\r\n\timplementation(\"org.springframework.boot:spring-boot-starter-actuator\")\r\n\timplementation(\"io.micrometer:micrometer-registry-prometheus\")\r\n\r\n    // ...\r\n}","application-apiyml#application-api.yml":"application-api.yml 파일에 spring.application.name, server.tomcat.mbeanregistry.enabled, management.metrics.tags.application, management.endpoints.web.exposure.include = prometheus를 추가해줍니다.\nspring:\r\n  application:\r\n    name: coupon-api\r\n\r\n# ...\r\n# ...\r\n\r\nserver:\r\n  port: 8080\r\n  tomcat:\r\n    mbeanregistry:\r\n      enabled: true\r\nmanagement:\r\n  metrics:\r\n    tags:\r\n      application:\r\n        ${spring.application.name}\r\n  endpoints:\r\n    web:\r\n      exposure:\r\n        include: prometheus","coupon-issuer#coupon-issuer":"이번에는 coupon-issuer 측의 설정입니다.","buildgradlekts-1#build.gradle.kts":"spring-boot-starter-actuator, micrometer-registry-prometheus 를 의존성으로 추가해줍니다.\n// ...\r\n\r\ndependencies {\r\n    // ...\r\n\r\n    // prometheus\r\n\timplementation(\"org.springframework.boot:spring-boot-starter-actuator\")\r\n\timplementation(\"io.micrometer:micrometer-registry-prometheus\")\r\n\r\n    // ...\r\n}","application-issueryml#application-issuer.yml":"application-issuer.yml 파일에 spring.application.name, server.tomcat.mbeanregistry.enabled, management.metrics.tags.application, management.endpoints.web.exposure.include = prometheus를 추가해줍니다.\nspring:\r\n  application:\r\n    name: coupon-issuer\r\n\r\n# ...\r\n# ...\r\n\r\nserver:\r\n  port: 8081 # 8081 포트를 사용합니다. 주의해주세요.\r\n  tomcat:\r\n    mbeanregistry:\r\n      enabled: true\r\nmanagement:\r\n  metrics:\r\n    tags:\r\n      application:\r\n        ${spring.application.name}\r\n  endpoints:\r\n    web:\r\n      exposure:\r\n        include: prometheus","coupon-api-coupon-issuer-모듈-구동#coupon-api, coupon-issuer 모듈 구동":"coupon-api, coupon-issuer 모듈을 각각 스프링부트 애플리케이션으로 구동합니다. 각각 8080, 8081 포트에 구동됩니다.","prometheus-메트릭-조회-가능-여부-확인#prometheus 메트릭 조회 가능 여부 확인":"간단하게 coupon-api 측에서의 접근이 가능한지를 확인해봅니다.\r\nhttp://host.docker.internal:8080/actuator/prometheus 으로 접속해주세요. 만약 docker 에서 prometheus 를 띄우지 않고 로컬호스트에서 prometheus 를 구동했다면 http://localhost:8080/actuator/prometheus으로 접속하시면 됩니다.\n아래와 같이 메트릭 조회가 성공적으로 되어야 합니다. 비정상일 경우 White Label Error Page 오류가 나타납니다.\r\ncoupon-issuer 에 대해서도 같은 방식으로 동작을 확인해보시기 바랍니다.","docker-compose-prometheus-grafana-세팅#Docker-Compose Prometheus, Grafana 세팅":"","monitoringprometheusconfigconfigyml#monitoring/prometheus/config/config.yml":"0.performance-test/monitoring/prometheus/config/config.yml 을 아래와 같이 작성합니다.\nglobal:\r\n  scrape_interval: 5s\r\n\r\nscrape_configs:\r\n  - job_name: \"coupon-api\"\r\n    metrics_path: '/actuator/prometheus'\r\n    static_configs:\r\n      - targets: [ 'host.docker.internal:8080' ]\r\n  - job_name: \"coupon-issuer\"\r\n    metrics_path: '/actuator/prometheus'\r\n    static_configs:\r\n      - targets: [ 'host.docker.internal:8081' ]","docker-composeyml#docker-compose.yml":"0.performance-test/monitoring/docker-compose.yml 을 아래와 같이 작성합니다.\nversion: '3.7'\r\nservices:\r\n  prometheus:\r\n    image: prom/prometheus\r\n    container_name: prometheus\r\n    volumes:\r\n      - ./prometheus/config:/etc/prometheus\r\n      - ./prometheus/volume:/prometheus\r\n    ports:\r\n      - 9090:9090\r\n    command:\r\n      - '--config.file=/etc/prometheus/config.yml'\r\n    restart: always\r\n    networks:\r\n      - prometheus_network\r\n  grafana:\r\n    image: grafana/grafana\r\n    container_name: grafana\r\n    ports:\r\n      - 3000:3000\r\n    volumes:\r\n      - ./grafana/volume:/var/lib/grafana\r\n    restart: always\r\n    networks:\r\n      - prometheus_network\r\nnetworks:\r\n  prometheus_network:\r\n    driver: bridge\n작성이 완료되었으면 터미널에서 0.performance-test/monitoring/ 으로 이동 후에 아래의 명령어를 수행합니다.\ndocker-compose up -d","grafana-세팅#Grafana 세팅":"이번에는 Grafana 에서 Prometheus 를 설정하는 방식을 알아봅니다.","grafana-접속--패스워드-변경#Grafana 접속 & 패스워드 변경":"Grafana 에 접속합니다. 접속 주소는 http://localhost:3000 입니다.\r\nid = admin, password = admin 을 입력하고 접속합니다.\r\n비밀번호를 변경하는 페이지입니다. 비밀번호를 변경하기 귀찮다면 Skip 버튼을 클릭하고, 변경할 것이라면 New password, Confirm new password 를 모두 입력하고 Submit 버튼을 눌러서 비밀번호 변경을 완료합니다.","dashboard-생성-prometheus-세팅#Dashboard 생성, Prometheus 세팅":"새로 나타난 페이지에서는 Dashboard > Create your first dashboard 를 클릭해서 대시보드 설정 페이지로 이동합니다.\r\nImport a dashboard 를 클릭합니다.\r\n새로 나타난 페이지에서 4701 을 입력하고 Load 버튼을 클릭합니다.\r\nConfigure a new datasource 버튼을 클릭합니다.\r\n나타난 datasource 선택 화면에서 Prometheus 를 선택합니다.\r\nPrometheus URL 은 http://host.docker.internal:9090 을 입력해줍니다.\r\n스크롤을 아래로 내려서 Save & test 버튼을 클릭해서 Prometheus 설정을 마무리합니다.\r\n다시 홈으로 이동 후  Dashboard > Create your first dashboard 를 클릭해서 대시보드 설정 페이지로 이동합니다.\r\n그리고 Import a dashboard 를 클릭합니다.\r\nprometheus 를 선택하고 Import 버튼을 클릭합니다.\r\n설정이 완료되면 아래와 같은 화면이 나타납니다.","prometheus-대시보드#Prometheus 대시보드":"Prometheus 대시보드는 http://localhost:9090/ 으로 접속하시면 됩니다.\r\n그리고 상단의 Status 클릭 → Targets 클릭을 차례로 수행해주시면 됩니다.\r\n![](./img/PROMETHEUS-SCREENSHOT/1.그리고 상단의 Status 클릭 → Targets 클릭 png)\n아래에 나타나는 api 들은 모두 monitoring/prometheus/config/config.yml 에 미리 지정해준 내용을 기반으로 세팅된 내용들입니다","지표들을-지우고-싶다면#지표들을 지우고 싶다면":"prometheus, grafana 와 같은 시계열 데이터를 저장하는 플랫폼들은 대부분 측정한 지표들을 디스크내에 증분방식으로 쌓아둡니다. 우리가 작성한 docker-compose 파일 내에도 volume 항목을 보면 이런 내용들을 저장하는 부분들에 대한 내용이 있습니다.\r\n위에서 표시된 부분에 쌓인 데이터들을 지우려면 각각의 volume 디렉터리를 삭제해주시면 됩니다."}},"/project-overview/module-structure":{"title":"멀티 모듈 구조","data":{"coupon-core#coupon-core":"DomainEvent\n각종 ErrorCode, Exception\nJPA Entity, Cache Value Object","coupon-dataaccess#coupon-dataaccess":"JPA, Querydsl, Redis, RedisScript, Caffeine 에 대한 처리 코드들을 모아두고 JPA 설정 코드들이 모여 있는 모듈입니다.\n처음에는 coupon-dataaccess 에 데이터 코드를 모아둘까 하다가 귀차니즘 으로 이렇게 하는 것 같다는 생각이 들어서 프로젝트 중반에 coupon-api, coupon-issuer 마다 각각의 데이터 접근코드를 두기로 결정했었습니다.\n막상 개발과 설계를 수정하는 과정을 거치면서 coupon 이라는 서비스 측면에서 data 조회의 버전을 따로 관리하는 모듈을 따로 분리해둔다면 더 나을 것이라는 판단이 들어서 coupon-dataaccess 모듈을 따로 구현하게 되었습니다.","coupon-api#coupon-api":"사용자의 접근 포인트\n사용자의 요청이 잘못 되었는지 유효성 검증 수행\nWrite Back 기반으로 요청들을 쌓아두는 역할을 수행\ne.g.\n쿠폰 1개에 대해 10000 명의 사용자가 접속해서 발급하려 하는 경우\n주요 코드\ncontroller, advice\ncoupon-dataaccess 를 이용해서 Redis Queue 처리 작업을 하고, ErrorCode, Exception 등은 coupon-core 모듈을 이용","coupon-issuer#coupon-issuer":"쿠폰 발급기 (실제 DB에 저장하는 작업을 수행)\nRedis 에 저장된 쿠폰 발급 요청을 꺼내어서 MySQL에 쿠폰 발급 요청 데이터를 실제로 저장하는 작업 수행\n스케쥴링(@Scheduled) 기반의 데이터 저장 처리\nMySQL에 데이터 저장 작업 완료시 CouponIssueCreatedEvent 라는 도메인 이벤트 발급(publish)\nCouponIssueCreatedEvent 리스너는 @TransactionalEventListener 를 통해 트랜잭션 커밋이 완료된 couponId 를 Redis 내에 Cache Aside 기반의 캐싱 처리\n저장된 데이터의 모습\n{\"@class\":\"io.chagchagchag.project.coupon.dataaccess.cache.redis.valueobject.CouponRedisEntity\",\"id\":1,\"couponAssignType\":\"FIFO\",\"totalQuantity\":[\"java.math.BigDecimal\",1000],\"isQuantityAvailable\":false,\"issueStartDate\":[2024,1,1,0,0,1],\"issueEndDate\":[2024,11,11,23,59,59]}","추가-개발이-필요한-부분들#추가 개발이 필요한 부분들":"이번 프로젝트는 Redis Script 를 통해 단건 INSERT 트래픽 (쿠폰 발급)을 어떻게 부하를 줄여서 처리하는 지에 대한 예제를 남기는 것이 목적입니다. 제대로 한다면 예외 발생 시에 Kafka 토픽에 에러내용을 기록하거나 카프카 마저도 저장이 안될 경우 File 기반의 IO 작업을 수행하는 부분, 우아한 종료 로직 내에 장애 내용, 처리 시도 중인 ID 등을 기록하는 로직 등이 필요한데, 이런 내용은 주제에서 벗어나기에 생략했습니다.\n예외 케이스를 떠올리면서 이 정도로 변태 처럼 예외케이스를 생각할 필요는 없다구 하고 생각이 들어서 가급적 이번 예제는 트래픽을 단순하게 Redis 작업 큐 (LIST, SET) 기반으로 처리하는 예제를 남기는 데에 중점을 두었습니다."}},"/project-overview/tech-stack":{"title":"Tech Stack","data":{"library#Library":"Spring Boot 3.2.2\nGradle Kotlin DSL\nLanguage : Java 21\nSpring Data JPA, Querydsl\nGradle Jib","infra#Infra":"Docker, Docker Compose\nRedis\nMySQL"}},"/redis-summary/known-cache-strategies":{"title":"Known Cache Strategies","data":{"많이-알려진-캐시-전략들#많이 알려진 캐시 전략들":"Cache Aside\nfeat. Spring Cache Manager\nWrite Back\nfeat. 작업 대기열\nWirte Through\n캐싱과 IO 작업을 함께 처리"}},"/":{"title":"Introduction","data":{"":"Project Github : https://github.com/chagchagchag/coupon-service\nDocs Github : https://github.com/chagchagchag/docs-coupon-service\n안녕하세요. 이 프로젝트 게시판은 Redis와 Spring Boot 를 이용해서 작업 대기열을 어떻게 처리하는지, 모니터링 도구는 어떻게 구성하는지를 알아갈 수 있는 예제와 여기에 대한 문서자료를 담은 페이지입니다.\n트래픽이 엄청 높은 경우에는 레디스를 사용할 경우 Memory 가 터질 수 있다는 위험요소도 있고 트래픽의 실제 범위를 알 수 없기에 실무에서 적용하기에 완벽하게 적합한 예제는 아닙니다.\r\n트래픽이 굉장히 높은 구조에서는 무한한 트래픽을 수용할 수 있도록 증분 기록이 가능하도록 하는 편이고, 디스크 용량 역시 외부에서 수정이 가능한 구조로 설계해야 하고, 보통은 이런 요구사항들은 실무에서는 카프카와 EDA, 분산 트랜잭션을 통해 이런 부분들을 해결합니다.\r\n카프카 역시 디스크에 메시징 기록들을 증분기록하는 방식이고 내부적으로는 RocksDB라는 Offheap 기반 데이터베이스를 사용하고, 토픽의 모든 내용들이 디스크에 기록이 되기에 이벤트가 모두 기록된다는 장점이 있고 EDA 의 SAGA, Outbox 개념을 통해 분산 트랜잭션을 통해 단일 DB로 요청이 몰릴 경우에 대한 위험을 분산하고 가용성을 늘리며, 트랜잭션을 이벤트 기반으로 처리함으로써 유지보수성을 향상시키는 편입니다.\n다만, 이번 예제는 단순히 레디스를 어떻게 사용하는지, RedisScript 는 무엇인지, 모니터링 도구는 어떻게 구성하고, 테스트 환경은 어떻게 구성하는지, 프로젝트에서는 어떤 코드 작성방식을 선택했는지 등을 설명하기 위해 간단한 문서페이지를 작성했습니다.\n제 입장에서는 취업을 위해 어쩔 수 없이 준비했지만, 혹시라도 들르셨을 지도 모르는 디지털 나그네분들에게 조금이라도 도움이 되기를 바랍니다."}},"/redis-summary/redis-data-structures":{"title":"Redis Data Structures","data":{"레디스-자료구조들#레디스 자료구조들":"String\nLIST\nSET\nSorted Set\nSortedSet\r\n예를 들면, 주식 종목 검색이나 주식 종목 초성검색을 구현할 때 Sorted Set을 사용합니다.List, Set\r\nList 의 LPUSH, LPOP, RPUSH, RPOP 을 적절하게 활용해서 작업 대기열을 구성할 수도 있습니다. 요청의 고유값을 식별하기 위해서는 Set 에 요청 ID 를 기록해두는 방식을 사용합니다.\r\n최근 트렌드는 가급적 작업 대기열 등은 Kafka,Kafka Streams 또는 RabbitMQ를 사용하는 추세입니다. 하지만 팀내 인력상황, 마감기한 및 여러가지 운영 요소로 인해 큰 비용이 필요하지 않을 경우 간단하게 레디스 기반으로 작업 대기열을 구성하는 경우도 많습니다.\r\n이 경우, Redis 서버가 다운될 경우 작업 대기열의 데이터들 모두 유실될 수 있다는 점에 착안해서 예외 처리등을 명확히 해둬야 합니다.\nString\r\n특정 값을 저장하는 용도로 사용합니다. 단순 문자열을 저장할 수도 있겠지만 구분자(DELIMITER)를 기반으로 여러가지 요청 식별자를 조합해서 어떤 요청이 있었는지를 기반으로 조회가 가능하도록 저장하는 경우도 많습니다.","string-자료구조#String 자료구조":"단순한 문자열 데이터 형식\r\n주요 연산으로는 set, get 이 있습니다.\r\nset, get 은 시간복잡도가 각각 O(1) 입니다.","eg-set#e.g. set":"set coupon:1 \"Apple 50% Discount Event\"\r\nOK","eg-get#e.g. get":"get coupon:1\r\n\"Apple 50% Discount Event\"\n이렇게 생성한 자료구조는 del 명령어로 삭제 가능합니다.","list-자료구조#List 자료구조":"리스트와 같은 선형자료 구조\r\nLPUSH 로 리스트의 제일 왼쪽(head)에 데이터를 추가할 수도 있고 RPUSH 로 리스트의 제일 오른쪽(tail)에 데이터를 추가할 수 있습니다.","lrange#LRANGE":"redis.io/commands - LRANGE\nLIST 내의 지정된 범위에 해당하는 요소들을 반환합니다.\n시간복잡도 O(S+N) 에 해당하는 연산입니다.\nS는 시작 Offset 의 Head/Tail 로부터의 거리 (distance)를 의미합니다.\nN은 지정된 Range 내에 속한 요소들의 개수를 의미합니다.\nLRANGE key start stop","lpush#LPUSH":"redis.io/commands - LPUSH\n리스트의 제일 왼쪽(head)에 데이터를 추가하는 연산입니다.\n시간복잡도 O(1) 에 해당하는 연산입니다.\nLPUSH key element [element ...]","rpush#RPUSH":"redis.io/commands - RPUSH\n리스트의 제일 오른쪽(tail)에 데이터를 추가하는 연산입니다.\n시간복잡도 O(1) 에 해당하는 연산입니다.\nRPUSH key element [element ...]","lpop#LPOP":"redis.io/commands - LPOP\n리스트의 첫 번째 요소(Head)를 지운 후 리턴하는 연산입니다.\n시간복잡도 O(N) 에 해당하는 연산입니다.\nLPOP key [count]\n리스트의 첫 번째로부터 몇 번째 요소를 지울지를 지정해서 지울 수도 있는데 이 경우 LPOP key 3 과 같은 명령을 내리면 제일 처음 요소로부터 3개의 요소를 POP 하게 됩니다.","rpop#RPOP":"redis.io/commands - RPOP\n리스트의 제일 마지막 요소(Tail)을 지운 후 리턴하는 연산입니다.\n시간복잡도 O(N) 에 해당하는 연산입니다.\nRPOP key [count]\n리스트의 마지막으로부터 몇 번째 요소를 지울지를 지정해서 지울 수도 있는데 이 경우 LPOP key 3 과 같은 명령을 내리면 맨끝에서 3개의 요소를 POP 하게 됩니다.","llen#LLEN":"redis.io/commands - LLEN\n현재 리스트의 사이즈를 리턴합니다.\n시간복잡도 O(1) 에 해당하는 연산입니다.\nLLEN key","lpos#LPOS":"redis.io/commands - LPOS\n리스트 내에서 일치하는 요소를 찾는 연산입니다.\n시간복잡도 O(N) 에 해당하는 연산입니다. 만약 MAXLEN 을 명시해서 호출하면 상수 시간 내에 수행됩니다.\nLPOS key element [RANK rank] [COUNT num-matches] [MAXLEN len]","set-자료구조#SET 자료구조":"어느 언어에서든 제공되는 Set 개념에 해당하는 자료구조입니다.","smembers#SMEMBERS":"redis.io/commands - SMEMBERS\nkey 에 해당하는 Set 에 저장된 모든 요소들을 반환합니다.\n시간복잡도 O(N) 에 해당하는 연산입니다.\nSMEMBERS key","sadd#SADD":"redis.io/commands - SADD\nkey 에 해당하는 Set 에 요소를 추가합니다. 이때 요소 하나만 지정할 수도 있고 요소 여러개를 지정해서 여러개의 요소를 한번에 추가할 수 도 있습니다.\n요소 하나를 추가할 때는 시간복잡도 O(1) 에 해당하는 연산입니다. 만약 요소 K 개를 하나의 명령어로 추가할 경우에는 O(K) 의 시간복잡도를 가집니다.\nSADD key member [member ...]","sismember#SISMEMBER":"redis.io/commands - SISMEMBER\nkey 에 해당하는 Set 에 member 에 해당하는 요소가 존재하는지 검사합니다. 존재한다면 1을, 존재하지 않는다면 0 을 리턴합니다.\n시간복잡도 O(1) 에 해당하는 연산입니다.\nSISMEMBER key member","scard#SCARD":"redis.io/commands - SCARD\nkey 에 해당하는 Set의 사이즈(Cardinality, 요소의 갯수)를 리턴합니다.\n시간복잡도 O(1) 에 해당하는 연산입니다.\nSCARD key","srem#SREM":"redis.io/commands - SREM\nkey 에 해당하는 Set 내에서 인자값으로 전달받은 member를 삭제하는 연산입니다. 지우고자 하는 요소가 여러개라면 지루려는 요소들을 모두 인자값으로 전달해주면 됩니다.\n지워야하는 요소수가 K개일 경우 시간복잡도 O(K) 가 소요되는 연산입니다.\nSREM key member [member ...]","sorted-set#Sorted Set":"스코어를 기반으로 순서를 지정해서 정렬된 상태로 저장하는 문자열 컬렉션입니다.\r\nSet 자료구조이므로 중복을 허용하지 않습니다.","zrange#ZRANGE":"redis.io/commands - ZRANGE\nkey 에 해당하는 SortedSet 에서 cli 에 명시한 Range 에 해당하는 요소들을 리턴하는 연산입니다.\nO(log(N)+M) 의 시간복잡도가 소요됩니다. N 은 정렬된 집합의 요소 수를 의미하며, M 은 반환된 요소 수를 의미합니다.\nZRANGE key start stop [BYSCORE | BYLEX] [REV] [LIMIT offset count]\r\n[WITHSCORES]","zadd#ZADD":"redis.io/commands - ZADD\nkey 에 해당하는 SortedSet 에 score 와 함께 요소들을 저장합니다. score 를 기반으로 정렬되며, score가 같은 요소는 문자열 정렬을 통해 오름차순 정렬되어 저장됩니다.\nO(log(N)) 의 시간복잡도가 소요됩니다. N 은 정렬된 집합의 요소 수를 의미합니다.\nZADD key [NX | XX] [GT | LT] [CH] [INCR] score member [score member\r\n...]\ne.g. redis> ZADD myzset 1 \"one\"\ne.g. redis> ZADD myzset 2 \"two\" 3 \"three\"","zcard#ZCARD":"redis.io/commands - ZCARD\nkey 에 해당하는 SortedSet 의 사이즈(Cardinality, 요소의 개수)를 리턴합니다.\nO(1) 의 시간복잡도가 소요됩니다.\nZCARD key","zpopmin#ZPOPMIN":"redis.io/commands - ZPOPMIN\nkey 에 해당하는 SortedSet 에서 score 가 가장 낮은 순으로 요소들 제거한 후 제거한 요소들을 리턴합니다.\nO(log(N)*M) 의 시간복잡도가 소요됩니다.\nZPOPMIN key [count]","zpopmax#ZPOPMAX":"redis.io/commands - ZPOPMAX\nkey 에 해당하는 SortedSet 에서 score 가 가장 높은 요소들을 제거한 후 제거한 요소들을 리턴합니다.\nO(log(N)*M) 의 시간복잡도가 소요됩니다.\nZPOPMAX key [count]"}},"/redis-summary/spring-data-redis":{"title":"Spring Data Redis","data":{"spring-data-redis#Spring Data Redis":""}}}